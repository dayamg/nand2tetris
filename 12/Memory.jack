// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {

    static Array ram, heap;
    static int freeList, lastList; // freeList: pointer to the first free list.

    /** Initializes the class. */
    function void init() {
        let ram = 0;
        let heap = 2048; // heap base
        let heap[0] = null; // when the pointer is null, we know that it's the last list.
        let heap[1] = 14334; // size of heap, stored in the second cell
        let freeList = 0; // index of the head of the first free list
        let lastList = 0;

        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        return ram[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let ram[address] = value;
        return;
    }


    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
        var int currListPointer, allocBaseAddress;
        let currListPointer = freeList;

        while ((size + 2 > heap[currListPointer + 1]) & (~(heap[currListPointer] = null))) {
            let currListPointer = heap[currListPointer] - heap;  // index of the next list
        }

        /// If we exited the loop since we reached the end and still no possible list, return null
        if ((size + 2 > heap[currListPointer + 1]) & (heap[currListPointer] = null)) {
            return null;  // No block found. Should not happen to often.
        }

        /// Else, we found a possible list. carve a block of size _size_ from it, and return its base address
        let allocBaseAddress = currListPointer + heap[currListPointer + 1] + 2 - size;
        let heap[allocBaseAddress] = null;  // Set "next" pointer to null.
        let heap[currListPointer + 1] = heap[currListPointer + 1] - size;
        let heap[allocBaseAddress + 1] = size;
        return heap + allocBaseAddress + 2;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array block) {
        /// append the array block in the end of freeList
        let heap[lastList] = block - 2; // connect the last list to the block
        let lastList = block - 2;  // update the lastList pointer to point at the base address of block
        return;
    }    
}
